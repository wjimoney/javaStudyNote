##  Java进阶

### IO

#### 1.IO流概述

其中：表示intput，是数据从硬盘进内存的过程，称之为读。
O表示output，是数据从内存到硬盘的过程。称之为写。

#### 2.IO流分类

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221022210326935.png" alt="image-20221022210326935" style="zoom:80%;" />

#### 3.字节流写数据

步骤：

##### 1.创建字节输出流对象:

注意事项：如果文件不存在，就创建。如果文件存在就清空。

##### 2.写数据

注意事项：写出的整数，实际写出的是整数在码表上对应的字母。

##### 3.释放资源

注意事项：每次使用完流必须要释放资源。

#### 4.字节流写数据的3种方式

![image-20221022210819105](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221022210819105.png)

#### 5.字节流写数据的两个小问题

字节流写数据如何实现换行呢？

##### 1.写完数据后，加换行符

![image-20221023145133293](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221023145133293.png)

windows:\r\n

linux:\n 

mac:\r

##### 2.字节流写数据如何实现追加写入呢？


1.public FileOutputStream（String name，boolean append）

2.创建文件输出流以指定的名称写入文件。默认是false,如果第二个参数写true，不会清空文件里面的内容

#### 6.字节流带try......catch的标准格式

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221022211216740.png" alt="image-20221022211216740" style="zoom:67%;" />

#### 7.小结

##### 1.创建字节输出流对象

文件不存在，就创建。
文件存在就清空。如果不想被清空则加true

##### 2.写数据

可以写一个字节，写一个字节数组，写一个字节数组的一部分,写一个回车换行：\r\n

##### 3.释放资源

#### 8.字节流读数据（一次读一个字节）

步骤：

##### 1.创建字节输入流对象。

//如果文件存在，那么就不会报错
//如果文件不存在，那么就直接报错

##### 2.读数据

//一次读取一个字节，返回值就是本次读到的那个字节数据
//也就是字符在码表中对应的那个数字，

//如果我们想要看到的是字符数据，那么一定要强转成char

##### 3.释放资源

##### 4.读数据的格式

###### 1.一次读写一个字节

![image-20221022221024121](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221022221024121.png)

###### 2.一次读写一个数组

![image-20221022221754793](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221022221754793.png)

![image-20221022221842425](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221022221842425.png)

#### 9.字节缓冲流:

##### 1.字节缓冲流：

```java
BufferOutputStream：字节缓冲输出流

BufferedlnputStream：字节缓冲输入流
```

##### 2.构造方法：

```java
字节缓冲输出流：BufferedOutputStream（OutputStream out）

字节缓冲输入流：BufferedlnputStream（InputStream in）
```

##### 3.为什么构造方法需要的是字节流，而不是具体的文件或者路径呢？

字节缓冲流仅仅提供缓冲区，而真正的读写数据还得依靠基本的字节流对象进行操作

##### 4.缓冲流一次写一个字节代码实现

![image-20221022221927830](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221022221927830.png)

##### 5.缓冲流一次写一个字节数组

![image-20221022222013766](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221022222013766.png)

#### 10.小结

##### 1.字节流：

可以操作（拷贝）所有类型的文件字节

##### 2.缓冲流：

不能直接操作文件，需要传递字节流

##### 3.拷贝文件的四种方式：

1.字节流一次读写一个字节

2.字节流一次读写一个字节数组

3.字节缓冲流一次操作一个字节

4.字节缓冲流一次操作一个字节数组

#### 11.汉字存储和展示过程解析

![image-20221023204057260](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221023204057260.png)

重点：windows默认使用码表为：GBK，一个字符两个字节。

idea和以后工作默认使用Unicode的UTF-8编解码格式，一个中文三个字节。

#### 12.字符串中的编码解码问题

[^字符流的底层是字节流+编码表]: 



##### 1.编码：

1.bytell getBytes（）：使用平台的默认字符集将该String编码为一系列字节，将结果存储到新的字节数组中.

2.byte]getBytes（String charsetName）：使用指定的字符集将该String编码为一系列字节，将结果存储到新的字节数组中

##### 2.解码：

1.String（bytel]bytes）：通过使用平台的默认字符集解码指定的字节数组来构造新的String 

2.String（byte[]bytes，String charsetName）：通过指定的字符集解码指定的字节数组来构造新的String

#### 13.为什么字节流读取文本文件，可能会出现乱码？

因为字节流读中文，每次只能读一部分所以出现了乱码。

#### 14.小结

1,想要进行拷贝，一律使用字节流或者字节缓冲流。

2,想要把文本文件中的数据读到内存中，请使用字符输入流。

想要把内存中的数据写到文本文件中，请使用字符输出流。

3,GBK码表一个中文两个字节，UTF-8编码格式一个中文3个字节。

#### 15.字符流写数据

步骤：

##### 1, 创建字符输出流对象。

注意事项：

如果文件不存在，就创建。但是要保证父级路径存在。
如果文件存在就清空。

##### 2,写数据

注意事项：

1，写出int类型的整数，实际写出的是整数在码表上对应的字母。

2，写出字符串数据，是把字符串本身原样写出。

##### 3,释放资源

注意事项：每次使用完流必须要释放资源。

#### 16.字符流写数据的5种方式,以及flush和close方法

![image-20221023210636917](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221023210636917.png)

![image-20221023210647498](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221023210647498.png)

#### 17.读数据的格式

##### 1.一次读取一个字符

![image-20221023210901960](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221023210901960.png)

##### 2.一次读取多个字符

1.方法

![image-20221023211007442](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221023211007442.png)

2.格式

![image-20221023211024752](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221023211024752.png)

#### 18.字符缓冲流

##### 1.字符缓冲流：

BufferedWriter：可以将数据高效的写出。

BufferedReader：可以将数据高效的读取到内存。

![image-20221023220551330](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221023220551330.png)

##### 2.构造方法：

BufferedWriter（Writer out）

BufferedReader（Reader in）

##### 3.字符缓冲流特有功能

BufferedWriter：

void newLine(）：写一行行分隔符，行分隔符字符申由系统属性定义



BufferedReader：

public String readLine(）：读一行文字。结果包含行的内容的字符串，不包括任何行终止字符，如果流的结尾已经到达，则为null

![image-20221023220527836](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221023220527836.png)

#### 19.IO小结

![image-20221023220812357](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221023220812357.png)

#### 20.其他流

##### 1.转换流

1.转换流的介绍

![image-20221024220535562](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221024220535562.png)

![image-20221024220618614](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221024220618614.png)

2.指定编码

![image-20221024220845584](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221024220845584.png)

![image-20221024220855221](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221024220855221.png)

##### 2.对象操作流

1.特点

可以把对象以字节的形式写到本地文件，直接打开文件，是读不懂的，需要再次用对象操作流读到内存中。

2.对象操作流的介绍

![image-20221024222644295](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221024222644295.png)

对象操作流分为两类：对象操作输入流和对象操作输出流



对象操作输出流（对象序列化流）：就是将对象写到本地文件中，或者在网络中传输

对象对象操作输入流（对象反序列化流）：把写到本地文件中的对象读到内存中，或者接收网络中传输的对象

3.对象操作流的注意事项

如果想要这个类的对象能够被序列化,那么这个类需要实现一个接口.Serializable

用对象序列化流序列化了一个对象后，假如我们修改了对象所属的Javabean类，读取数据会不会出问题呢？

会出问题，会抛出InvalidClassException异常

如果出问题了，如何解决呢？

给对象所属的类加一个serialVersionUID

private static final long serialVersionUID = 42L

如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？

给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程

4.对象操作流操作多个对象

![image-20221024224046050](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221024224046050.png)

![image-20221024224050668](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221024224050668.png)

这是打印器读取出来的两种方法

#### 21.Properties

##### 1.Properties概述：

是一个Map体系的集合类

Properties中有跟IO相关的方法

只存字符串

##### 2.Properties作为集合的特有方法

![image-20221025201252330](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221025201252330.png)

3.PropertiesheIO流结合的方法

![image-20221025201434612](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221025201434612.png)

![image-20221025201439628](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221025201439628.png)

Properties   load方法的例子:

![image-20221025201514340](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221025201514340.png)

### 多线程

#### 1.概述

##### 1.简单了解多线程

是指从软件或者硬件上实现多个线程并发执行的技术。

具有多线程能力的计算机因有硬件支持而能够在同一时间执行多个线程，提升性能。

##### 2.并发和并行

并行：在同一时刻，有多个指令在多个CPU上同时执行。

并发：在同一时刻，有多个指令在单个CPU上交替执行。

##### 3.进程和线程

进程：就是操作系统中正在运行的一个应用程序。

线程：就是应用程序中做的事情。比如：360软件中的杀毒，扫描木马，清理垃圾。

#### 2.多线程的实现方案

##### 方案1：继承Thread类

```
1.定义一个类MyThread继承Thread类
2.在MyThread类中重写run（方法)
3.创建MyThread类的对象
4.启动线程
5.两个小问题：
为什么要重写run())方法
因为run()是用来封装被线程执行的代码
run()方法和start()方法的区别？
run()：封装线程执行的代码，直接调用，相当于普通方法的调用，并没有开启线程。
start()：启动线程；然后由JVM调用此线程的run0方法
```

案例:

![image-20221025210020947](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221025210020947.png)

##### 方案2：实现Runnable接口

```java
1.定义一个类MyRunnable家现Runnable接口
2.在MyRunnable类中重写run()方法
3.创建MyRunnable类的对象
4.创建Thread类的对象，把MyRunnable对象作为构造方法的参数
5.启动线程
```



##### 方案3：Callable和Future

```java
1.定义一个类MyCallable实现Callable接口
2.在MyCallable类中重写call（）方法
3.创建MyCallable类的对象
4.创建Future的实现类FutureTask对象，把MyCallable对象作为构造方法的参数
5.创建Thread类的对象，把FutureTask对象作为构造方法的参数
6.启动线程
7.再调用get方法，就可以获取线程结束之后的结果。
```

#### 3.Thread方法

##### 1.获取和设置线程名称

获取线程的名字
•String getName()：返回此线程的名称

Thread类中设置线程的名字

void setName（String name）：将此线程的名称更改为等于参数name

通过构造方法也可以设置线程名称

##### 2.获得当前线程的对象

public static Thread currentThread（）：返回对当前正在执行的线程对象的引用

##### 3.线程休眠

public static void sleep（long time）：让线程休眠指定的时间，单位为毫秒。

##### 4.线程的优先级

1.线程调度

多线程的并发运行：计算机中的CPU，在任意时刻只能执行 条机器指令。每个线程只有获得CPU的使用权才能执行代码。
各个线程轮流获得CPU的使用权，分别执行各自的任务。

线程有两种调度模型

分时调度模型：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片

抢占式调度模型：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线获取的CPU时间片相对多一些

public final void setPriority（int newPriority） 设置线程的优先级
public final int getPriority()                                   获取线程的优先级

线程的优先级为:1-10,默认值为:5

##### 5.后台线程/守护线程

public final void setDaemon（boolean on）：设置为守护线程

#### 4.线程安全问题

##### 1.买票案例

需求：某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票

###### 1.使用实现Runnable的方法编写多线程程序

```java
//请使用”实现Runnable接口”的方式编写多线程程序，模拟三个窗口同时卖100张票的情况，暂不考虑处理线程安全问题.
//
//运行并打印结果，观察到错误的数据，并解释出现错误的原因。
public static void main(String[] args) {
    MyRunnable myRunnable = new MyRunnable();
    Thread thread = new Thread(myRunnable);
    Thread thread1 = new Thread(myRunnable);
    Thread thread2 = new Thread(myRunnable);
    thread.setName("窗口一");
    thread1.setName("窗口二");
    thread2.setName("窗口三");
    thread.start();
    thread1.start();
    thread2.start();
}




public class MyRunnable implements Runnable{
    private int piao=100;
    private Object obj=new Object();
    @Override
    public void run() {
        while(true){
            synchronized (obj){
                if(piao<=0){
                    System.out.println(Thread.currentThread().getName()+"票卖完了");
                    break;
                }else{
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    piao--;
                    System.out.println(Thread.currentThread().getName()+"还剩"+piao+"张票");
                }
            }
        }
    }
}
```



###### 2.请使用”继承Thread类”的方式编写多线程程序，模拟三个窗口同时卖100张票的情况，要求: 处理线程安全问题。

**注意事项:**

**像这种"继承Thread类”的方式编写多线程程序"的方法当创建3个对象时MyThread myThread = new MyThread();**
        **MyThread myThread1 = new MyThread();**
        **MyThread myThread2 = new MyThread();**

**需要在类中用stsstic修饰:**

 **private static int piao=100;**

**而且锁对象也不能用Object了**

**要用类名.class**

```
 1.需要让piao,也就是票数, 让三个对象共享, 所以需要使用static关键字
 2.要保证三个对象的锁对象是同一个.
 private static Object obj = new Object();   //普通对象锁,需要加上static
类名.class        //不需要做特殊处理,因为类的字节码文件,永远只有一个
```

```java
public class Test3 {
    //请使用”继承Thread类”的方式编写多线程程序，模拟三个窗口同时卖100张票的情况，
    // 要求: 处理线程安全问题。
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        MyThread myThread1 = new MyThread();
        MyThread myThread2 = new MyThread();
        myThread.setName("窗口一");
        myThread1.setName("窗口二");
        myThread2.setName("窗口三");
        myThread.start();
        myThread1.start();
        myThread2.start();
    }
}


public class MyThread extends Thread{
    private static int piao=100;

    @Override
    public void run() {
        while(true){
            synchronized (MyThread.class){
                if(piao<=0){
                    System.out.println(Thread.currentThread().getName()+"票卖完了");
                    break;
                }else{
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    piao--;
                    System.out.println(Thread.currentThread().getName()+"还剩"+piao+"张票");
                }
            }
        }
    }
}
```

##### 2.同步代码块

```java
锁多条语句操作共享数据，可以使用同步代码块实现

格式：
synchronized（任意对象）{
    多条语句操作共享数据的代码
}
默认情况是打开的，只要有一个线程进去执行代码了，锁就会关闭
当线程执行完出来了，锁才会自动打开
同步的好处和弊端
好处：解决了多线程的数据安全问题
弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率
```

![image-20221026171805556](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221026171805556.png)

##### 3.锁对象唯一

```
一般锁对象写的是类中的private object obj=new object()中的obj,但是This也可以作为锁对象,但是要分情况当这个类创建多个对象时那么This就不是唯一的了不能作为
synchronized（任意对象）{
    多条语句操作共享数据的代码
}里面的对象了,因为锁对象要有唯一性,但是如果只创建了一个对象那么This可以作为锁对象
字符串也可以作为锁对象,因为字符串在常量池里是惟一的,但是我们推荐使用"类名.class"
```

##### 4.同步方法

```
同步方法：就是把synchronized关键字加到方法上

格式：修饰符synchronized返回值类型方法名（方法参数）{}
同步代码块和同步方法的区别：
同步代码块可以锁住指定代码，同步方法是锁住方法中所有代码
同步代码块可以指定锁对象,同步方法不能指定锁对象
同步方法的锁对象是什么呢？
this

同步静态方法：就是把synchronized关键字加到静态方法上
格式：修饰符static synchronized返回值类型方法名（方法参数）{}
同步静态方法的锁对象是什么呢？
类名.class
```

##### 5.Lock锁

```
虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，

为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock
Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作
Lock中提供了获得锁和释放锁的方法
void lock()：获得锁
void unlock()：释放锁
注意事项:
在使用lock方法时,需要创建Reentrantlock对象如下图
```

![image-20221027000717947](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221027000717947.png)

#### 5.死锁

线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。

死锁是由于锁的嵌套导致的,以后不要写锁的嵌套

#### 6.等待和唤醒的方法

为了体现生产和消费过程中的等待和唤醒，Java就提供了几个方法供我们使用，这几个方法在Object类中Object类的等待和唤醒方法：

![image-20221026201118334](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221026201118334.png)

注意事项: 使用什么对象当做锁,那么就必须去用这个对象去调用等待和唤醒的方法

#### 7.线程的状态

![image-20221026210113151](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221026210113151.png)

![image-20221026210117493](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221026210117493.png)

#### 8.线程池

##### 1.代码实现

![image-20221026211842496](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221026211842496.png)

##### 2.创建Executors中的静态方法

```
//static ExecutorService newcachedThreadPool（）创建一个默认的线程池
池子中默认是空的.默认最多可以容纳int类型的最大值.
//static newFixedThreadPool（int nThreads）创建一个指定最多线程数量的线程池
池子中默认是空的.指定的是最多可以容纳多少个线程
```

###### 举例说明

Excutors中的静态方法,sumit()方法和shutdown方法在代码中的使用

![image-20221026212440341](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221026212440341.png)

##### 3.创建线程池对象

###### 写法及注意事项

```java
ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor
（核心线程数量，最大线程数量，空闲线程最大存活时间，任务队列，创建线程工厂，任务的拒绝策略）；
参数一：核心线程数量         写数字1,2,3等            不能小于0
参数二：最大线程数          写数字1,2,3等            不能小于等于0，最大数量>=核心线程数量
参数三：空闲线程最大存活时间  写数字1,2,3等            不能小于0
参数四：时间单位            参数三的单位,TimeUnit.时间单位      时间单位
参数五：任务队列            new ArrayBlockingQueue<>(填写排队的数量)    不能为null 
参数六：创建线程工厂         Excutors.defaultThreadFactory()           不能为null
参数七：任务的拒绝策略       new ThreadPoolExcutor.AbortPolicy()表示超过任务队列的数量的不要了   不能为null
```

![image-20221026222429313](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221026222429313.png)

TimeUnit的时间单位

![image-20221026215123166](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221026215123166.png)

###### ThreadPoolExecutor在代码中体现

```
//创建线程池
ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(3,5,30, TimeUnit.SECONDS,new ArrayBlockingQueue<>(10), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());
//给线程池任务,让其执行,同时线程池自己创建线程对象
threadPoolExecutor.submit(new MyThread());
threadPoolExecutor.submit(new MyThread());
threadPoolExecutor.submit(()->{
    System.out.println(Thread.currentThread().getName()+"代码运行了");
});
threadPoolExecutor.submit(()->{
    System.out.println(Thread.currentThread().getName()+"代码运行了");
});
//关闭线程池
threadPoolExecutor.shutdown();
```

任务拒绝策略

ThreadPoolExecutor.AbortPolicy.  丢弃任务并抛出RejectedExecutionException异常。是默认的策略。

ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常这是不推荐的做法。

ThreadPoolExecutor.DiscardOldestPolicy：抛弃队列中等待最久的任务然后把当前任务加入队列中。

ThreadPoolExecutor.CallerRunsPolicy：调用任务的run()方法绕过线程池直接执行。

### 网络编程

#### 1.网络编程三要素

##### 1.概述

网络编程三要素

**IP地址**

设备在网络中的地址，是唯一的标识。

**端口**

应用程序在设备中唯一的标识。

**协议**

数据在网络中传输的规则，常见的协议有UDP协议和TCP协议。


##### 2.IP地址

**常用命令：**
ipconfig：查看本机IP地址
ping IP地址：检查网络是否连通
**特殊IP地址：**
127.0.0.1：是回送地址也称本地回环地址，可以代表本机的IP地址，一般用来测试使用

3.InetAddress类

```
static InetAddress getByName（String host）

确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址

string getHostName（）获取此IP地址的主机名

string getHostAddress（）返回文本显示中的IP地址字符串
```

注意事项:InetAddress类没有构造方法,而调用类中非静态的方法时用getByName(String host)方法,该方法会返回一个InetAddress对象,用这个对象调用类中的非静态方法.

##### 3.端口

**端口**：应用程序在设备中唯一的标识。

**端口号**：用两个字节表示的整数，它的取值范围是0~65535。其中0~1023之间的端口号用于一些知名的网络服务或者应用。
我们自己使用1024以上的端口号就可以了。

注意：一个端口号只能被一个应用程序使用。

推荐使用10000以上的端口号

##### 4.协议

**协议**：计算机网络中，连接和通信的规则被称为网络通信协议

**UDP协议**
用户数据报协议（User Datagram Protocol）
UDP是面向无连接通信协议。
速度快，有大小限制一次最多发送64K，数据不安全，易丢失数据。

**TCP协议**
传输控制协议（Transmission Control Protocol）
TCP协议是面向连接的通信协议。速度慢，没有大小限制，数据安全。

5.小结
**网络编程**：就是可以让两台计算机进行数据交互。
数
**网络编程三要素**：

IP：设备在网络中唯一的标识。
端口号：应用程序在设备中唯一的标识。

协议：数据在传输过程中遵守的规则。

##### 5.UDP发送数据

![image-20221028223451724](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221028223451724.png)

![image-20221028223502320](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221028223502320.png)

##### 6.UDP

###### 1.UDP接收数据![image-20221028223534375](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221028223534375.png)

![image-20221028223545884](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221028223545884.png)

![image-20221028223626092](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221028223626092.png)

![image-20221029141635530](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221029141635530.png)

注意事项:

1.要先运行接收端，再运行发送端

2.如果接收端再启动之后，没有接收到数据，那么会死等（阻塞）.

###### 2..UDP的三种通讯方式

单播
组播
广播

**组播代码实现**

UDP通信组播代码实现
组播地址：224.0.0.0 ~ 239.255.255.255
其中224.0.0.0~ 224.0.0.255为预留的组播地址

![image-20221029001109000](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221029001109000.png)

![image-20221029001334039](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221029001334039.png)

![image-20221029001418746](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221029001418746.png)

![image-20221029001528847](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221029001528847.png)

广播代码实现

**广播地址：255.255.255.255**

![image-20221029002346825](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221029002346825.png)

**接收端与单播的代码一样**

![image-20221029002524210](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221029002524210.png)

##### 7.TCP

1.通讯原理

TCP通信协议是一种可靠的网络协议，它在通信的两端各建立一个Socket对象。
通信之前要保证连接已经建立。
通过Socket产生IO流来进行网络通信。

2.TCP发送数据

![image-20221029152910811](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221029152910811.png)

```java
 public static void main(String[] args) throws IOException {
        //创建服务器对象
        ServerSocket serverSocket = new ServerSocket(10000);
        //等待客户端连接
        Socket accept = serverSocket.accept();
        //读取数据
        InputStream inputStream = accept.getInputStream();
        byte[] b=new byte[1024];
        int a;
        while((a=inputStream.read(b))!=-1){
            System.out.println(new String(b,0,a));
        }
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream()));
        bufferedWriter.write("你好吗");
        bufferedWriter.flush();
        serverSocket.close();
    }
```

![image-20221029152939219](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221029152939219.png)

```java
public static void main(String[] args) throws IOException {
    //创建客户端对象
    Socket socket = new Socket("192.168.0.122",10000);
    //创建IO流对象
    OutputStream outputStream = socket.getOutputStream();
    //写入数据
    outputStream.write("你好".getBytes());
    socket.shutdownOutput();
    //把socket.getInputStream()转化为字符流
    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
    String s;
    while ((s=bufferedReader.readLine())!=null){
        System.out.println(s);
    }
    //释放资源
    socket.close();
}
```

###### 3.TCP发送和接收本地文件

**客户端发送****

```java
//客户端需求：把一个图片文件发送到服务端并读取回馈信息。
//
//服务端需求：接收客户端发送过来的图片数据。进行存储后，回馈一个“上传成功”字样。支持多用户的并发访问。
public static void main(String[] args) throws IOException {
    //创建客户端对象
    Socket socket = new Socket("192.168.0.122", 10000);
    //读取本地文件
    BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream("11_8k.jpg"));
    //发送数据
    BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(socket.getOutputStream());
    byte[] by=new byte[1024];
    int a;
    while ((a=bufferedInputStream.read(by))!=-1){
        bufferedOutputStream.write(by,0,a);
    }
    socket.shutdownOutput();
    //接收服务端数据
    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
    String s;
    while ((s=bufferedReader.readLine())!=null){
        System.out.println(s);
    }
    bufferedInputStream.close();
    bufferedReader.close();
    socket.close();
}
```

**服务端接收**

```java
public static void main(String[] args) throws IOException {
    ServerSocket serverSocket = new ServerSocket(10000);
    //等待连接
    Socket accept = serverSocket.accept();
    //接收数据
    BufferedInputStream bufferedInputStream = new BufferedInputStream(accept.getInputStream());
    //保存本地
    BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream("美女.jpg"));
    byte[] by=new byte[1024];
    int a;
    while ((a=bufferedInputStream.read(by))!=-1){
        bufferedOutputStream.write(by,0,a);
    }
    //发送数据
    BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream()));
    bufferedWriter.write("上传成功");
    bufferedWriter.close();
    bufferedInputStream.close();
    bufferedOutputStream.close();
    serverSocket.close();
}
```

##### 8.服务端优化

###### 原始代码:

```java
public static void main(String[] args) throws IOException {
    ServerSocket serverSocket = new ServerSocket(10000);
    //等待连接
    Socket accept = serverSocket.accept();
    //接收数据
    BufferedInputStream bufferedInputStream = new BufferedInputStream(accept.getInputStream());
    //保存本地
    BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream("美女.jpg"));
    byte[] by=new byte[1024];
    int a;
    while ((a=bufferedInputStream.read(by))!=-1){
        bufferedOutputStream.write(by,0,a);
    }
    //发送数据
    BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream()));
    bufferedWriter.write("上传成功");
    bufferedWriter.close();
    bufferedInputStream.close();
    bufferedOutputStream.close();
    serverSocket.close();
}
```

###### 1.第一个弊端：

**服务器只能处理一个客户端请求，接收完一个图片之后，服务器就关闭了。**
**改进方式：循环**

```java
public static void main(String[] args) throws IOException {
    ServerSocket serverSocket = new ServerSocket(10000);
    //等待连接
    while (true) {
        Socket accept = serverSocket.accept();
        //接收数据
        BufferedInputStream bufferedInputStream = new BufferedInputStream(accept.getInputStream());
        //保存本地
        BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream("美女.jpg"));
        byte[] by=new byte[1024];
        int a;
        while ((a=bufferedInputStream.read(by))!=-1){
            bufferedOutputStream.write(by,0,a);
        }
        //发送数据
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream()));
        bufferedWriter.write("上传成功");
        bufferedWriter.close();
        bufferedInputStream.close();
        bufferedOutputStream.close();
    }
   // serverSocket.close();
}
```

###### 2.第二个弊端：

**第二次上传文件的时候，会把第一次的文件给覆盖。**
**改进方式：UUID.randomUUIDO方法生成随机的文件名**

```java
public static void main(String[] args) throws IOException {
    ServerSocket serverSocket = new ServerSocket(10000);
    //等待连接
    while (true) {
        Socket accept = serverSocket.accept();
        //接收数据
        BufferedInputStream bufferedInputStream = new BufferedInputStream(accept.getInputStream());
        //保存本地
        BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(UUID.randomUUID().toString()+".jpg"));
        byte[] by=new byte[1024];
        int a;
        while ((a=bufferedInputStream.read(by))!=-1){
            bufferedOutputStream.write(by,0,a);
        }
        //发送数据
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream()));
        bufferedWriter.write("上传成功");
        bufferedWriter.close();
        bufferedInputStream.close();
        bufferedOutputStream.close();
    }
   // serverSocket.close();
}
```

###### 3.第三个弊端：

**弊端：**
**无法同时处理多个客户端的请求**

**改进方式：增加多线程**

**主方法:**

```java
public static void main(String[] args) throws IOException {
    ServerSocket serverSocket = new ServerSocket(10000);
    while (true) {
        //等待连接
        Socket accept = serverSocket.accept();
        //接收数据
        Threadsocket threadsocket = new Threadsocket(accept);
        new Thread(threadsocket).start();
    }
   // serverSocket.close();
}
```

**Rannable的实现类**



```java
public class Threadsocket implements Runnable{
    private Socket acceptsocket;
    public Threadsocket(Socket accept) {
        this.acceptsocket=accept;
    }
@Override
public void run() {
    BufferedInputStream bufferedInputStream=null;
    BufferedOutputStream bufferedOutputStream=null;
    BufferedWriter bufferedWriter=null;
    try {
        bufferedInputStream = new BufferedInputStream(acceptsocket.getInputStream());
        //保存本地
        bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(UUID.randomUUID().toString()+".jpg"));
        byte[] by=new byte[1024];
        int a;
        while ((a=bufferedInputStream.read(by))!=-1){
            bufferedOutputStream.write(by,0,a);
        }
        //发送数据
        bufferedWriter = new BufferedWriter(new OutputStreamWriter(acceptsocket.getOutputStream()));
        bufferedWriter.write("上传成功");

    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if(bufferedInputStream!=null){
            try {
                bufferedInputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if(bufferedWriter!=null){
            try {
                bufferedWriter.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        if(bufferedOutputStream!=null){
            try {
                bufferedOutputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

###### 4.第四个弊端：

**加入多线程以后又引发了一个问题：使用多线程虽然可以让服务器同时处理多个客户端请求。但是资源消耗太大。**

**改进方式:加入线程池**

```java
public static void main(String[] args) throws IOException {
    ServerSocket serverSocket = new ServerSocket(10000);
    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(3, 5, 30,
            TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(10),
            Executors.defaultThreadFactory(),
            new ThreadPoolExecutor.AbortPolicy());
    while (true) {
        //等待连接
        Socket accept = serverSocket.accept();
        //接收数据
        Threadsocket threadsocket = new Threadsocket(accept);
        threadPoolExecutor.submit(threadsocket);
    }
   // serverSocket.close();
}
```

**Rannable的实现类同上**

### 日志

#### 1.日志技术的特点

1.通过使用日志技术，我们可以控制日志信息输送的目的地是控制台、文件等位置。
2.我们也可以控制每一条日志的输出格式。
3.通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。
4.最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。

#### 2.Logback快速入门

导入Logback的相关jar包

```java
private static final Logger LOGGER= LoggerFactory.getLogger(类名.class);
```

编写Logback配置文件

在代码中获取日志的对象

按照级别设置记录日志信息

#### 3.日志的6种级别


级别程度依次是：TRACE< DEBUG< INFO<WARN<ERROR < FATAL

默认级别是debug（忽略大小写）LOGGER.error（"error级别的日志信息"）；

作用：将开发中不同的日志信息进行分类，只输出大于等于该级别的日志信息。

### 枚举



#### 1.概述

枚举
为了间接的表示一些固定的值，Java就给我们提供了枚举。

格式：public enum s {

枚举项1，枚举项2，枚举项3；

}

#### 3.特点

1.所有枚举类都是Enum的子类
2.我们可以通过"枚举类名.枚举项名称"去访问指定的枚举项
3.每一个枚举项其实就是该枚举的一个对象4.枚举也是一个类，也可以去定义成员变量
5.枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略6.枚举类可以有构造器，但必须是private的，它默认的也是private的。
枚举项的用法比较特殊：枚举（""）；
7.枚举类也可以有抽象方法，但是枚举项必须重写该方法

#### 4.枚举的方法

```java
String name()            获取枚举项的名称

int ordinal（）         返回枚举项在枚举类中的索引值

int compareTo（E o）比较两个枚举项，返回的是索引值的差值

String toString（）               返回枚举常量的名称

static <T> T valueOf（Class<T> type，String name）获取指定枚举类中的指定名称的枚举值

values（）获得所有的枚举项
```



### 类加载器

#### 1.概述

类加载器：负责将.class文件（存储的物理文件）加载在到内存中

#### 2.类加载时机

1.创建类的实例（对象）

2.调用类的类方法

3.访问类或者接口的类变量，或者为该类变量赋值4.使用反射方式来强制创建某个类或接口对应的java.lang.Class对象

5.初始化某个类的子类

6.直接使用java.exe命令来运行某个主类用到就加载，不用不加载

#### 3.类加载的过程

![image-20221030223517754](E:/DEVELOP/typora/images/image-20221030223517754.png)

1.加载

2.链接

3.初始化

4.小结

4.类加载器的分类
启动类加载器（Bootstrap ClassLoader）：虚拟机内置的类加载器。

平台类加载器（Platform Classloader）：负责加载JDK中一些特殊的模块。

系统类加载器（System Classloader）：负责加载用户类路径上所指定的类库。

5.类加载器的方法

public static ClassLoader getSystemClassLoader）
获取系统类加载器

public InputStream getResourceAsStream（String name）加载某-资源文件

注意事项:

```java
语法:
	//我们一般会用"类的加载器"帮我们加载"配置文件"
	InputStream is = 当前类类名.class.getClassLoader().getResourceAsStream("配置文件名字");
注意:
	1.配置文件必须放在src目录下.
    2.如果配置文件在src的根目录下,则直接写配置文件的名字
    3.如果配置文件在src中的包中,则书写"包名/配置文件名字"
```



### 反射

#### 1.反射概述

##### 1.Java反射机制

是在运行状态中，对于任意一个类，都能够知道这个

类的所有属性和方法；对于任意一个对象，都能够调

用它的任意属性和方法；这种动态获取信息以及动态

调用对象方法的功能称为Java语言的反射机制。

##### 2.简化概述:

Java反射机制

利用反射可以无视修饰符获取类里面所有的属性和方法。

先获取配置文件中的信息，动态获取信息并创建对象

和调用方法

#### 2.获取Class对象

##### 1.获取Class方法的三种方法的原理

![image-20221031170255001](E:/DEVELOP/typora/images/image-20221031170255001.png)

##### 2.获取Class对象的三种方法

###### 1.Class.forName（"全类名"）；

```java
//获取Class对象
//1.Class类中的静态方法,forname("全类名")
//全类名:包名+类名
Class aClass = Class.forName("com.itheima.Practice.Student");
System.out.println(aClass);
```

###### 2.类名.class

```java
//2.通过class属性来获取,类名.class
Class studentClass = Student.class;
System.out.println(studentClass);
```

###### 3.对象.getClass()；

```java
//3.利用对象的getclass方法来获取class对象
//getclass方法是定义在object方法里的
Student student = new Student();
Class aClass1 = student.getClass();
System.out.println(aClass1);
```

#### 3.Constructor(获取类中构造方法)

##### 1.获取Constructor构造方法

反射获取构造方法并使用

Class类中用于获取构造方法的方法

Constructor<？>[]getConstructors（）：返回所有公共构造方法对象的数组

```java
//获取Class对象
Class aClass = Class.forName("com.itheima.Practice.Student");
//返回所有公共构造方法对象的数组
Constructor[] constructors = aClass.getConstructors();
for (Constructor constructor : constructors) {
    System.out.println(constructor);
}
```

Constructor<？>]getDeclaredConstructors）：返回所有构造方法对象的数组

```java
//获取Class对象
Class aClass = Class.forName("com.itheima.Practice.Student");
//返回所有构造方法对象的数组
Constructor[] declaredConstructors = aClass.getDeclaredConstructors();
for (Constructor declaredConstructor : declaredConstructors) {
    System.out.println(declaredConstructor);
}
```

Constructor<T> getConstructor（Class<？>...parameterTypes）：返回单个公共构造方法对象

```java
//获取Class对象
Class aClass = Class.forName("com.itheima.Practice.Student");
//返回单个公共构造方法对象
//注意小括号里的形参一定要和构造方法的形参保持一致
Constructor constructor = aClass.getConstructor();//这个时获得的空惨的构造方法所以小括号里什么也不写
System.out.println(constructor);
Constructor constructor1 = aClass.getConstructor(String.class, int.class);//这个时获得的有参构造所以里面写"参数.class"
System.out.println(constructor1);
```

Constructor<T> getDeclaredConstructor（Class<？>..parameterTypes）：返回单个构造方法对象

```java
//获取Class对象
Class aClass = Class.forName("com.itheima.Practice.Student");有一个简化写法
//返回返回单个构造方法对象
//注意小括号里的形参一定要和构造方法的形参保持一致
Constructor declaredConstructor = aClass.getDeclaredConstructor();;//这个时获得的空惨的构造方法所以小括号里什么也不写
System.out.println(declaredConstructor);
Constructor declaredConstructor1 = aClass.getDeclaredConstructor(String.class, int.class);//这个时获得的有参构造所以里面写"参数.class"
System.out.println(declaredConstructor1);
```

##### 2.利用Constructor创造对象

T newInstance（Object...initargs）：根据指定的构造方法创建对象

**注意事项:**

如果是获取无参构造那么有一个简化写法

```
//获取Class对象
Class aClass = Class.forName("com.itheima.Practice.Student");有一个简化写法
//如果是获取无参构造那么有一个简化写法
Object o = aClass.newInstance();
```

//被private修饰的成员,不能直接使用

//如果用反射强行获取病使用,需要临时取消访问检查(调用setAccessible方法)

```java
  Constructor constructor1 = aClass.getConstructor(String.class, int.class);
//.利用Constructor创造对象(创造公共有参构造方法的对象)
Student zhangsan = (Student) constructor1.newInstance("zhangsan", 22);
--------------------------------------------------------
  Constructor declaredConstructor1 = aClass.getDeclaredConstructor(String.class, int.class);   
//被private修饰的成员,不能直接使用
//如果用反射强行获取病使用,需要临时取消访问检查(调用setAccessible方法)
 declaredConstructor1.setAccessible(true);
//.利用Constructor创造对象(创造私有有参构造方法的对象)
 Student zhangsan1 = (Student) declaredConstructor1.newInstance("zhangsan", 22);
```

##### 3.小结

###### 1.获取class对象

三种方式----Class.forName（“全类名”）---------三种方法中比较常用的

###### 2.获取里面的构造方法对象

getConstructor（Class<？>...parameterTypes）

getDeclaredConstructor（Class<？>...parameterTypes）

###### 3.如果是public的，直接创建对象

newlnstance（Object...initargs）

如果是非public的，需要临时取消检查，然后再创建对象

setAccessible（boolean）---------------该方法又被称为暴力放射

#### 4.Fild对象

##### 1.获取Fild对象(获取类中的成员变量)

```java
//Field[]getFields）：返回所有公共成员变量对象的数组
 //获得Class对象
   Class aClass = Class.forName("com.itheima.Practice.Student");
 //获得Filed对象----返回所有公共成员变量对象的数组
   Field[] fields = aClass.getFields();            
//Field[]getDeclaredFields）：返回所有成员变量对象的数组
 //获得Class对象
   Class aClass = Class.forName("com.itheima.Practice.Student");
//获得Filed对象----返回所有成员变量对象的数组
   Field[] declaredFields = aClass.getDeclaredFields();
//Field getField（String name）：返回单个公共成员变量对象
 //获得Class对象
   Class aClass = Class.forName("com.itheima.Practice.Student");
  //获得Filed对象----返回单个公共成员变量对象
   Field name = aClass.getField("name");
//Field getDeclaredField（String name）：返回单个成员变量对象第三步：赋值或者获取值
 //获得Class对象
   Class aClass = Class.forName("com.itheima.Practice.Student");
 //获得Filed对象----
   Field high = aClass.getDeclaredField("high");
```

##### 2.利用Filed赋值和获取值

注意事项:

//被private修饰的成员,不能直接使用

//如果用反射强行获取病使用,需要临时取消访问检查(调用setAccessible方法)

###### 赋值

```java
//获得Class对象
  Class aClass = Class.forName("com.itheima.Practice.Student");
//获取Filed对象
Field name = aClass.getField("name");
//获取无参构造
Student student = (Student) aClass.newInstance();
//利用Filed赋值
name.set(student,"zhangsan");
```

获取值

```java
//获得Class对象
  Class aClass = Class.forName("com.itheima.Practice.Student");
//获得Filed对象----
Field high = aClass.getDeclaredField("high");
Student student = (Student) aClass.newInstance();
//high被prvate修饰,所以取消一下访问检查
high.setAccessible(true);
//利用Filed获取值
high.get(student);
```

#### 5.Meyhod

注意事项:

//被private修饰的成员,不能直接使用

//如果用反射强行获取病使用,需要临时取消访问检查(调用setAccessible方法)

##### 1.获得Meyhod对象

```java
Class aClass = Class.forName("com.itheima.Practice.Student");
//MethodD getMethodss：返回所有公共成员方法对象的数组，包括继承的
Method[] methods = aClass.getMethods();
//Method[getDeclaredMethods（）：返回所有成员方法对象的数组，不包括继承的
Method[] declaredMethods = aClass.getDeclaredMethods();
//Method getMethod（String name，Class<？>...parameterTypes）：返回单个公共成员方法对象
Method show = aClass.getMethod("show");
//Method getDeclaredMethod（String name，Class<？>...parameterTypes）：返回单个成员方法对象
Method show1 = aClass.getDeclaredMethod("show1", String.class);
```

##### 2.运行方法

```java
Object invoke（Object obj，Object...args）：
    运行方法参数一：用obj对象调用该方法
参数二：调用方法的传递的参数（如果没有就不写）
返回值：方法的返回值（如果没有就不写）
//1.获取class对象
class clazz = Class.forName（"com.itheima.myreflect5.Student"）；
//2，获取里面的Method对象 function4
Method method = clazz.getMethod（name："show1"，string.class）；
//3.运行function4方法就可以了
//3.1创建一个Student对象，当做方法的调用者
Student student =（Student）clazz.newInstance（）；
//show2方法被private修饰,所以取消一下访问检查
show2.setAccessible(true);
//3.2运行方法
object result = method.invoke（student,"zhangsan"）；
//4.打印一下返回值
System.out.println（result）；
```

### XML

#### 1.XML概述

XML的全称为（EXtensible Markup Language），是一种可扩展的标记语言标记语言：通过标签来描述数据的一门语言（标签有时我们也将其称之为元素）

可扩展：标签的名字是可以自定义的

可以理解为：XML文件是由很多标签组成的，而标签名是可以自定义的。

作用：

用于进行存储数据和传输数据

作为软件的配置文件

#### 2.XML标签

```java
1.标签由一对尖括号和合法标识符组成<student>
2.标签必须成对出现
<student>(开始标签)</student>(结束标签)
3.特殊的标签可以不成对，但是必须有结束标记<address/>
4.标签中可以定义属性，属性和标签名空格隔开属性值必须用引号引起来
//(单引号和双引号都可以)
<student id="1"> </student>
5.标签需要正确的嵌套
<student id="1">
<name>张三</name>
</student>
//这种嵌套是可以的
------------------
<student id="1">
<name>张三
</student>
</name>
//这种不可以
```

#### 3.文档声明

```java
格式:
	<?xml version="1.0" encoding="UTF-8"?>
解析:
    version	:当前xml的版本,必须有,且必须是"1.0"
    encoding:当前xml的编码方式. 一般为"UTF-8"
注意:
	1.任何xml文件都必须有文档声明
	2.文档声明必须放在xml文件的第一行第一列.
```

#### 4.语法规则

```java
1.XML中的标签必须有开始,有结束.
2.XML中的标签必须正确嵌套.
3.XML标签中的属性值一定要用引号引起来(单双都可以)
4.XML中标签区分大小写
5.XML中有且仅有一个跟标签
```

#### 5.特殊字符

```java
直接书写:
    &lt; 	小于号 
    &gt;  	大于号
    &amp;  	&符号
    &apos; 	单引号 
    &quot; 	双引号
    &nbsp; 	空格
CDATA区:
	<![CDATA[ 直接在这里书写任何内容,都是直接输出 ]]>
```

#### 6.解析

常见的解析思想

DOM（DocumentObject Model）文档对象模型：就

是把文档的各个组成部分看做成对应的对象。

会把xml文件全部加载到内存。

在内存中形成一个树形结构，再获取对应的值

Document对象：整个xml文档

Element对象：所有标签

Attribute对象：所有属性

Text对象：所有文本内容

代码

```java
//1.获取解析器对象
SAXReader saxReader = new SAXReader();
//2.利用解析器对象把xml文件读取到内存中,并返回一个文档对象
Document read = saxReader.read(new File("Day16\\xml\\students.xml"));
//3.获取跟标签
Element rootElement = read.getRootElement();
//4.通过根标签获取Student标签
//elments():可以获取调用者所有的子标签,会把这些子标签放到集合中返回
//elments("标签名"):可以获得调用者指定的所有子标签,会把这些子标签放到集合中返回
List<Element> student = rootElement.elements("student");
ArrayList<Student> list=new ArrayList<>();
//遍历集合,获得每一个子标签
for (Element element : student) {
    //elment表示每一个子标签
    //获取id这个属性
    Attribute attribute = element.attribute("id");
    //获取id的属性值
    String id = attribute.getValue();


    //获取name标签
    //element("标签名"):获取调用者指定的子标签
    Element name1 = element.element("name");
    //获取这个标签的标签体内容
    String name = name1.getText();



    //获取age标签
    Element age1 = element.element("age");
    //获取标签体内容
    String age = age1.getText();
    Student student1 = new Student(id, name, Integer.parseInt(age));
    list.add(student1);
}
for (Student student1 : list) {
    System.out.println(student1);
}
```

#### 6.1 解析步骤

##### ① 导入jar包

```java
dom4j-1.6.1.jar		//当前解析使用的是"dom4J"解析工具
```

##### ② 开始解析

```java
public class TestDemo {
    public static void main(String[] args) throws Exception {
        //1.创建一个解析器
        SAXReader saxReader = new SAXReader();
        //2.告诉解析器,要解析的文件是谁,返回要解析的文档
        Document document = saxReader.read(TestDemo.class.getClassLoader().getResourceAsStream("stus.xml"));
        //3.从文档中获取"跟标签"
        Element rootElement = document.getRootElement();

        //4.注意,解析时,必须一层一层的解析
        //4.1 获取"跟标签"下的"student"标签
        //Element studentEl = rootElement.element("student");  //获取"跟标签"下第一个student标签
        List<Element> students = rootElement.elements("student");    //获取"跟标签"下所有的student标签
        Element studentEl = students.get(1);                         //获取集合中索引为1的那个student标签

        //4.2 获取"Student标签"下的"name标签"中的内容
        // 获取"Student标签"下的"name标签"
        Element nameEl = studentEl.element("name");
        // 获取"name标签"中的内容
        String nameText = nameEl.getText();
        System.out.println(nameText);

        //4.3 获取"Student标签"下的"age标签"中的内容
        // 获取"Student标签"下的"age标签"
        Element ageEl = studentEl.element("age");
        // 获取"ageEl"中的内容
        String ageText = ageEl.getText();
        System.out.println(ageText);

        //4.4 获取"Student标签"中Id属性的值
        // 获取id属性的值
        String value =studentEl.attributeValue("id");
        System.out.println(value);
    }
}
```

##### ③ 文件内容

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<students>
    <student id="1">
        <name>张三</name>
        <age>23</age>
        <gender>男</gender>
    </student>

    <student id="2">
        <name>李四</name>
        <age>24</age>
        <gender>女</gender>
    </student>
</students>
```

### DTD

#### 1.DTD文档约束的步骤

```java
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE students SYSTEM 'studentdtd.dtd'>
<!--本xml用来描述多个学生信息-->
<students>
    <student>
        <name>李四</name>
        <age>18</age>
    </student>
</students>
---------------------------------
DTD文档约束
<!ELEMENT students (student,student)>
        <!ELEMENT student (name,age)>
        <!ELEMENT name (#PCDATA)>
        <!ELEMENT age (#PCDATA)>    
步骤：
1，创建一个文件，这个文件的后缀名为.dtd。
2，看xml文件中使用了哪些元素<！ELEMENT>可以定义元素
3，判断元素是简单元素还是复杂元素。
简单元素：没有子元素。
复杂元素：有子元素的元素；
<！ELEMENT persons（person）>复杂元素：有子元素的元素；
<！ELEMENT person（name，age）>复杂元素：有子元素的元素；
<！ELEMENT name（#PCDATA）>简单元素：没有子元素。
<！ELEMENT age（#PCDATA）> 简单元素：没有子元素。   
```

#### 2.xml引入约束

```java
引入本地DTD约束: <!DOCTYPE 跟标签 SYSTEM 'DTD文件路径'>
引入内部DTD约束: <!DOCTYPE 跟标签 [ DTD约束语法 ]>
引入网路DTD约束: <!DOCTYPE 跟标签 PUBLIC 'DTD文件名' 'DTD文件的URL'>
```

引入本地DTD约束:

```java
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE students SYSTEM 'studentdtd.dtd'>
<!--本xml用来描述多个学生信息-->
<students>
    <student>
        <name>李四</name>
        <age>18</age>
    </student>
</students>
```

引入内部DTD约束:

```java
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE students [
        <!ELEMENT students (student,student)>
        <!ELEMENT student (name,age)>
        <!ELEMENT name (#PCDATA)>
        <!ELEMENT age (#PCDATA)>
        ]>
<!--本xml用来描述多个学生信息-->
<students>
    <student>
        <name>李四</name>
        <age>18</age>
    </student>
</students>
```

引入网路DTD约束:

```java
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE students PUBLIC "dtd文件的名称" "dtd文档的URL">
<!--本xml用来描述多个学生信息-->
<students>
    <student>
        <name>李四</name>
        <age>18</age>
    </student>
</students>
```

#### 3.DTD语法规则

##### 1.DTD语法规则

```java
定义一个元素的格式为：<！ELEMENT元素名元素类型>
简单元素：
EMPTY：表示标签体为空
ANY：表示标签体可以为空也可以不为空
PCDATA：表示该元素的内容部分为字符串
    
复杂元素：
直接写了元素名称。
多个子元素可以使用","或者"|"隔开；

","表示定义子元素的顺序；
"|"表示子元素只能出现任意一个
"？"零次或一次，
"+"一次或多次，
"*"零次或多次；如果不写则表示出现一次
```

2.定义属性

```java
DTD语法规则
定义一个属性的格式为：<！ATTLIST元素名称属性名称属性的类型属性的约束>
属性的类型：
CDATA类型：普通的字符串
属性的约束：
#REQUIRED：必须的
#IMPLIED：属性不是必需的
#FIXED value：属性值是固定的
<!ATTLIST person id CDATA#FIXED"p1">
```

### schema

#### 文档约束编写

编写schema约束

+ 步骤

  1，创建一个文件，这个文件的后缀名为.xsd。
  2，定义文档声明
  3，schema文件的根标签为： <schema>
  4，在<schema>中定义属性：
  ​	xmlns=http://www.w3.org/2001/XMLSchema
  5，在<schema>中定义属性 ：
  ​	targetNamespace =唯一的url地址，指定当前这个schema文件的名称空间。
  6，在<schema>中定义属性 ：
  ​	elementFormDefault="qualified“，表示当前schema文件是一个质量良好的文件。
  7，通过element定义元素
  8，判断当前元素是简单元素还是复杂元素

<img src="E:/DEVELOP/typora/images/image-20221101201256133.png" alt="image-20221101201256133" style="zoom: 200%;" />

**代码实现**

```java
<?xml version="1.0" encoding="UTF-8" ?>
<schema
        xmlns="http://www.w3.org/2001/XMLSchema"//代表当前文件是一个约束文件
      targetNamespace="http://itheima.com"//把当前一整套约束起一个名字
        elementFormDefault="qualified"//表示当前文件中语法是严格的
<!--定义复杂元素        -->
<element name="students">
<complexType>
    <sequence>
        <!--定义复杂元素        -->
        <element name="student">
            <complexType>
            <sequence>
<!--                定义name和age简单元素-->
                <element name="name" type="String">
                <element name="age" type="String">
                </element>
            </sequence>
            </complexType>
        </element>
    </sequence>
</complexType>
</element>
></schema>
```

引入schema约束

+ 步骤

  1，在根标签上定义属性xmlns="http://www.w3.org/2001/XMLSchema-instance"
  2，通过xmlns引入约束文件的名称空间
  3，给某一个xmlns属性添加一个标识，用于区分不同的名称空间
  ​	格式为: xmlns:标识=“名称空间地址” ,标识可以是任意的，但是一般取值都是xsi
  4，通过xsi:schemaLocation指定名称空间所对应的约束文件路径
  ​	格式为：xsi:schemaLocation = "名称空间url 文件路径“

+ 代码实现

  ```java
  <?xml version="1.0" encoding="UTF-8" ?>
  
  <persons
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     //表示被别人约束 xmlns="http://www.itheima.cn/javase"
      xsi:schemaLocation="http://www.itheima.cn/javase person.xsd"
  
  ><person>
  >  <name>张三</name>
  >  <age>23</age>
  ></person>
  
  </persons>

#### schema约束-引入方式

```java
<!--xml引入Schema约束-->
<跟标签
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://www.itcast.cn/aaa"
    xsi:schemaLocation="http://www.itcast.cn/aaa student.xsd"

>

<!--
   引入其他约束详解:
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
			1.表示引入官网约束.
			2.表示当前文件是一个被约束的文件(固定写法)
			3.给"引入的官网约束"起了个别名叫做"xsi"
       xmlns="http://www.itcast.cn/aaa"         
			1.表示引入其他约束
			2.被引入的约束的名字叫做"http://www.itcast.cn/aaa". 注意:"http://www.itcast.cn/aaa"仅仅是一个名字
			3.该约束没有起别名,所以,是当前文件的默认约束
       xsi:schemaLocation="http://www.itcast.cn/aaa student.xsd"             
			1.指定被引入的自定义约束的路径
			2.格式为"自定义约束名 自定义约束位置"
-->
```

### 注解

#### 1.概述

```java
概述: 注解和注释一样,都是对对代码进行解释说明的. 注解是给计算机进行解释说明,注释是程序员进行解释说明
常见:
	@Override: 告诉计算机,我这个方法是"重写的方法".
	@Deprecated: 告诉计算机,我这个方法"过时了"
	@SuppressWarnings(value = "all"): 告诉计算机,我知道我这里有警告,你不要管了.
```

#### 2.自定义注解

```java
public @interface 注解名
    //数据类型 变量名() default 默认值
    string name();//default可以不写
    int age()default 22;
    String[] hobby() default{"排球","篮球"};
}
```

#### 3.注意事项(知道)

```java
1.注解本身没有任何意义.注解的功能取决于代码赋予的含义.
2.注解在使用时,必须给"注解的属性赋值".格式: @注解名(属性名=属性值)
3.如果注解的属性有默认值,则对应的属性可以不赋值,但是如果没有没默认值,则使用时必须赋值.
4.如果注解的属性名字是value,则单独给value赋值时,value可以省略. @注解名(属性值)
5.如果注解的属性是数组,则赋值时,可以直接赋与多个值. @注解名(属性名={值1,值2...})
5.如果注解的属性是数组,并且赋值时,只赋值一个值的话,{}可以省略.则赋值时,可以直接赋值. @注解名(属性名=值)
```

#### 自定义注解案例

+ 需求

  自定义一个注解@Test,用于指定类的方法上,如果某一个类的方法上使用了该注解,就执行该方法

+ 实现步骤

  1. 自定义一个注解Test,并在类中的某几个方法上加上注解
  2. 在测试类中,获取注解所在的类的Class对象
  3. 获取类中所有的方法对象
  4. 遍历每一个方法对象,判断是否有对应的注解

+ 代码实现

+ //表示Test这个注解的存活时间
  @Retention(value = RetentionPolicy.RUNTIME)
  public @interface Test {
  }

  public class UseTest {

      //没有使用Test注解
      public void show(){
          System.out.println("UseTest....show....");
      }
      
      //使用Test注解
      @Test
      public void method(){
          System.out.println("UseTest....method....");
      }
      
      //没有使用Test注解
      @Test
      public void function(){
          System.out.println("UseTest....function....");
      }
  }

  public class AnnoDemo {
      public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException {
          //1.通过反射获取UseTest类的字节码文件对象
          Class clazz = Class.forName("com.itheima.myanno3.UseTest");

  ```java
      //创建对象
      UseTest useTest = (UseTest) clazz.newInstance();
  
      //2.通过反射获取这个类里面所有的方法对象
      Method[] methods = clazz.getDeclaredMethods();
  
      //3.遍历数组，得到每一个方法对象
      for (Method method : methods) {
          //method依次表示每一个方法对象。
          //isAnnotationPresent(Class<? extends Annotation> annotationClass)
          //判断当前方法上是否有指定的注解。
          //参数：注解的字节码文件对象
          //返回值：布尔结果。  true 存在  false 不存在
          if(method.isAnnotationPresent(Test.class)){
              method.invoke(useTest);
          }
      }
  }
  
  ```

***isAnnotationPresent**(Class<? extends Annotation> annotationClass)**
        //判断当前方法上是否有指定的注解**。

#### 元注解(了解)

```java
概念:所谓的元注解,指的是,修饰自定义注解的注解
组成:
	@Retention: 表示,自定义注解可以什么时候用. RetentionPolicy.RUNTIME:表示在运行时仍然可以使用
	@Target: 表示,自定义注解可以在哪个地方用. @Target(ElementType.METHOD):表示自定义注解只能在方法上用
```



### 单元测试

#### 1.Junit概述

JUnit 是一个Java 编程语言的单元测试工具。JUnit是

一个非常重要的测试工具。

#### 2.Junit特点


JUnit是一个开放源代码的测试工具。

提供注解来识别测试方法。

JUnit 测试可以让你编写代码更快，并能提高质量。

JUnit优雅简洁。没那么复杂，花费时间较少。

**JUnit在一个条中显示进度。如果运行良好则是绿色；如果运行失败，则变成红色。**

#### 2.Junit使用的基本流程


将junit的jar包导入到工程中

编写测试方法该测试方法必须是公共的无参数无返回值的非静态方法

在测试方法上使用@Test注解标注该方法是一个测试方法

选中测试方法右键通过junit运行该方法

**断言:**Assert.assertEquals(期望的值,实际值)   (测试逻辑错误)

#### 3.Junit常用注解介绍

@Test

表示测试该方法

@Before

在测试的方法前运行

@After

在测试的方法后运行
